Index: glTFRenderer/glTFRenderPass/glTFComputePass/glTFComputePassReSTIRDirectLighting.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#pragma once\r\n#include \"glTFComputePassBase.h\"\r\n\r\nstruct RayTracingDIPostProcessPassOptions\r\n{\r\n    inline static std::string Name = \"RAY_TRACING_DI_POSTPROCESS_OPTION_CBV_INDEX\";\r\n    \r\n    bool enable_spatial_reuse;\r\n    bool enable_temporal_reuse;\r\n};\r\n\r\nclass glTFComputePassReSTIRDirectLighting : public glTFComputePassBase\r\n{\r\npublic:\r\n    glTFComputePassReSTIRDirectLighting();\r\n    \r\n    virtual const char* PassName() override;\r\n    virtual bool InitPass(glTFRenderResourceManager& resource_manager) override;\r\n    virtual bool PreRenderPass(glTFRenderResourceManager& resource_manager) override;\r\n    virtual bool PostRenderPass(glTFRenderResourceManager& resource_manager) override;\r\n\r\n    virtual DispatchCount GetDispatchCount() const override;\r\n    \r\n    virtual bool TryProcessSceneObject(glTFRenderResourceManager& resource_manager, const glTFSceneObjectBase& object) override;\r\n    virtual bool FinishProcessSceneObject(glTFRenderResourceManager& resource_manager) override;\r\n    virtual bool UpdateGUIWidgets() override;\r\n    \r\nprotected:\r\n    virtual bool SetupRootSignature(glTFRenderResourceManager& resource_manager) override;\r\n    virtual bool SetupPipelineStateObject(glTFRenderResourceManager& resource_manager) override;\r\n\r\nprivate:\r\n    DispatchCount m_dispatch_count;\r\n    \r\n    std::shared_ptr<IRHIRenderTarget> m_output;\r\n    RootSignatureAllocation m_output_allocation;\r\n    RHIGPUDescriptorHandle m_output_handle;\r\n\r\n    glTFRenderResourceUtils::RWTextureResourceWithBackBuffer m_aggregate_samples_output;\r\n    \r\n    // External resource\r\n    std::shared_ptr<IRHIRenderTarget> m_lighting_samples;\r\n    std::shared_ptr<IRHIRenderTarget> m_screen_uv_offset;\r\n\r\n    RHIGPUDescriptorHandle m_lighting_samples_handle;\r\n    RHIGPUDescriptorHandle m_screen_uv_offset_handle;\r\n    \r\n    RootSignatureAllocation m_lighting_samples_allocation;\r\n    RootSignatureAllocation m_screen_uv_offset_allocation;\r\n\r\n    RayTracingDIPostProcessPassOptions m_pass_options;\r\n};\r\n
===================================================================
diff --git a/glTFRenderer/glTFRenderPass/glTFComputePass/glTFComputePassReSTIRDirectLighting.h b/glTFRenderer/glTFRenderPass/glTFComputePass/glTFComputePassReSTIRDirectLighting.h
--- a/glTFRenderer/glTFRenderPass/glTFComputePass/glTFComputePassReSTIRDirectLighting.h	
+++ b/glTFRenderer/glTFRenderPass/glTFComputePass/glTFComputePassReSTIRDirectLighting.h	
@@ -7,6 +7,14 @@
     
     bool enable_spatial_reuse;
     bool enable_temporal_reuse;
+    int spatial_reuse_pixel_range;
+
+    RayTracingDIPostProcessPassOptions()
+        : enable_spatial_reuse(false)
+        , enable_temporal_reuse(false)
+        , spatial_reuse_pixel_range(0)
+    {
+    }
 };
 
 class glTFComputePassReSTIRDirectLighting : public glTFComputePassBase
Index: glTFRenderer/glTFRenderPass/glTFComputePass/glTFComputePassReSTIRDirectLighting.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"glTFComputePassReSTIRDirectLighting.h\"\r\n\r\n#include <imgui.h>\r\n\r\n#include \"glTFRenderPass/glTFRenderInterface/glTFRenderInterfaceFrameStat.h\"\r\n#include \"glTFRenderPass/glTFRenderInterface/glTFRenderInterfaceLighting.h\"\r\n#include \"glTFRenderPass/glTFRenderInterface/glTFRenderInterfaceSceneView.h\"\r\n\r\nglTFComputePassReSTIRDirectLighting::glTFComputePassReSTIRDirectLighting()\r\n    : m_aggregate_samples_output(\"AGGREGATE_OUTPUT_REGISTER_INDEX\", \"AGGREGATE_BACKBUFFER_REGISTER_INDEX\")\r\n{\r\n    AddRenderInterface(std::make_shared<glTFRenderInterfaceSceneView>());\r\n    AddRenderInterface(std::make_shared<glTFRenderInterfaceLighting>());\r\n    AddRenderInterface(std::make_shared<glTFRenderInterfaceFrameStat>());\r\n    AddRenderInterface(std::make_shared<glTFRenderInterfaceSingleConstantBuffer<RayTracingDIPostProcessPassOptions>>());\r\n}\r\n\r\nconst char* glTFComputePassReSTIRDirectLighting::PassName()\r\n{\r\n    return \"ReSTIR_Direct_Lighting_Pass\";\r\n}\r\n\r\nbool glTFComputePassReSTIRDirectLighting::InitPass(glTFRenderResourceManager& resource_manager)\r\n{\r\n    IRHIRenderTargetDesc lighting_output_desc;\r\n    lighting_output_desc.width = resource_manager.GetSwapchain().GetWidth();\r\n    lighting_output_desc.height = resource_manager.GetSwapchain().GetHeight();\r\n    lighting_output_desc.name = \"LightingOutput\";\r\n    lighting_output_desc.isUAV = true;\r\n    lighting_output_desc.clearValue.clear_format = RHIDataFormat::R8G8B8A8_UNORM;\r\n    lighting_output_desc.clearValue.clear_color = {0.0f, 0.0f, 0.0f, 0.0f};\r\n    \r\n    m_output = resource_manager.GetRenderTargetManager().CreateRenderTarget(\r\n        resource_manager.GetDevice(), RHIRenderTargetType::RTV, RHIDataFormat::R8G8B8A8_UNORM, RHIDataFormat::R8G8B8A8_UNORM, lighting_output_desc);\r\n    resource_manager.GetRenderTargetManager().RegisterRenderTargetWithTag(\"RayTracingOutput\", m_output);\r\n    \r\n    IRHIRenderTargetDesc aggregate_samples_output_desc;\r\n    aggregate_samples_output_desc.width = resource_manager.GetSwapchain().GetWidth();\r\n    aggregate_samples_output_desc.height = resource_manager.GetSwapchain().GetHeight();\r\n    aggregate_samples_output_desc.name = \"AggregateOutput\";\r\n    aggregate_samples_output_desc.isUAV = true;\r\n    aggregate_samples_output_desc.clearValue.clear_format = RHIDataFormat::R32G32B32A32_FLOAT;\r\n    aggregate_samples_output_desc.clearValue.clear_color = {0.0f, 0.0f, 0.0f, 0.0f};\r\n    \r\n    RETURN_IF_FALSE(m_aggregate_samples_output.CreateResource(resource_manager, aggregate_samples_output_desc))\r\n    \r\n    auto& command_list = resource_manager.GetCommandListForRecord();\r\n    RETURN_IF_FALSE(RHIUtils::Instance().AddRenderTargetBarrierToCommandList(command_list, *m_output, RHIResourceStateType::STATE_RENDER_TARGET, RHIResourceStateType::STATE_NON_PIXEL_SHADER_RESOURCE))\r\n\r\n    m_lighting_samples = resource_manager.GetRenderTargetManager().GetRenderTargetWithTag(\"ReSTIRDirectLightingSamples\");\r\n    m_screen_uv_offset = resource_manager.GetRenderTargetManager().GetRenderTargetWithTag(\"RayTracingScreenUVOffset\");\r\n    \r\n    RETURN_IF_FALSE(glTFComputePassBase::InitPass(resource_manager))\r\n\r\n    return true;\r\n}\r\n\r\nbool glTFComputePassReSTIRDirectLighting::PreRenderPass(glTFRenderResourceManager& resource_manager)\r\n{\r\n    RETURN_IF_FALSE(glTFComputePassBase::PreRenderPass(resource_manager))\r\n\r\n    auto& command_list = resource_manager.GetCommandListForRecord();\r\n    auto& GBuffer_output = resource_manager.GetCurrentFrameResourceManager().GetGBufferForRendering();\r\n    RETURN_IF_FALSE(GBuffer_output.Transition(GetID(), command_list, RHIResourceStateType::STATE_NON_PIXEL_SHADER_RESOURCE))\r\n\r\n    RETURN_IF_FALSE(RHIUtils::Instance().SetDTToRootParameterSlot(command_list,\r\n        m_lighting_samples_allocation.parameter_index, m_lighting_samples_handle, GetPipelineType() == PipelineType::Graphics))\r\n\r\n    RETURN_IF_FALSE(RHIUtils::Instance().SetDTToRootParameterSlot(command_list,\r\n        m_screen_uv_offset_allocation.parameter_index, m_screen_uv_offset_handle, GetPipelineType() == PipelineType::Graphics))\r\n\r\n    RETURN_IF_FALSE(RHIUtils::Instance().SetDTToRootParameterSlot(command_list,\r\n        m_output_allocation.parameter_index, m_output_handle, GetPipelineType() == PipelineType::Graphics))\r\n    \r\n    RETURN_IF_FALSE(GBuffer_output.Bind(GetID(), command_list, resource_manager.GetGBufferAllocations().GetAllocationWithPassId(GetID())))\r\n    RETURN_IF_FALSE(GetRenderInterface<glTFRenderInterfaceLighting>()->UpdateCPUBuffer())\r\n\r\n    RETURN_IF_FALSE(m_aggregate_samples_output.BindRootParameter(resource_manager))\r\n    \r\n    RETURN_IF_FALSE(RHIUtils::Instance().AddRenderTargetBarrierToCommandList(command_list, *m_output,\r\n       RHIResourceStateType::STATE_PIXEL_SHADER_RESOURCE, RHIResourceStateType::STATE_UNORDERED_ACCESS))\r\n\r\n    GetRenderInterface<glTFRenderInterfaceSingleConstantBuffer<RayTracingDIPostProcessPassOptions>>()->UploadCPUBuffer(&m_pass_options, 0, sizeof(m_pass_options));\r\n    \r\n    return true;\r\n}\r\n\r\nbool glTFComputePassReSTIRDirectLighting::PostRenderPass(glTFRenderResourceManager& resource_manager)\r\n{\r\n    RETURN_IF_FALSE(glTFComputePassBase::PostRenderPass(resource_manager))\r\n\r\n    auto& command_list = resource_manager.GetCommandListForRecord();\r\n    RETURN_IF_FALSE(m_aggregate_samples_output.CopyToBackBuffer(resource_manager))\r\n\r\n    RETURN_IF_FALSE(RHIUtils::Instance().AddRenderTargetBarrierToCommandList(command_list, *m_output,\r\n       RHIResourceStateType::STATE_UNORDERED_ACCESS, RHIResourceStateType::STATE_PIXEL_SHADER_RESOURCE))\r\n\r\n    return true;\r\n}\r\n\r\nDispatchCount glTFComputePassReSTIRDirectLighting::GetDispatchCount() const\r\n{\r\n    return m_dispatch_count;\r\n}\r\n\r\nbool glTFComputePassReSTIRDirectLighting::TryProcessSceneObject(glTFRenderResourceManager& resource_manager,\r\n                                                                const glTFSceneObjectBase& object)\r\n{\r\n    const glTFLightBase* light = dynamic_cast<const glTFLightBase*>(&object);\r\n    if (!light)\r\n    {\r\n        return false;\r\n    }\r\n    \r\n    return GetRenderInterface<glTFRenderInterfaceLighting>()->UpdateLightInfo(*light);\r\n}\r\n\r\nbool glTFComputePassReSTIRDirectLighting::FinishProcessSceneObject(glTFRenderResourceManager& resource_manager)\r\n{\r\n    RETURN_IF_FALSE(glTFComputePassBase::FinishProcessSceneObject(resource_manager))\r\n\r\n    return true;\r\n}\r\n\r\nbool glTFComputePassReSTIRDirectLighting::UpdateGUIWidgets()\r\n{\r\n    RETURN_IF_FALSE(glTFComputePassBase::UpdateGUIWidgets())\r\n\r\n    ImGui::Checkbox(\"EnableSpatialReuse\", &m_pass_options.enable_spatial_reuse);\r\n    ImGui::Checkbox(\"EnableTemporalReuse\", &m_pass_options.enable_temporal_reuse);\r\n\r\n    return true;\r\n}\r\n\r\nbool glTFComputePassReSTIRDirectLighting::SetupRootSignature(glTFRenderResourceManager& resource_manager)\r\n{\r\n    RETURN_IF_FALSE(glTFComputePassBase::SetupRootSignature(resource_manager))\r\n\r\n    auto& allocations = resource_manager.GetGBufferAllocations();\r\n    RETURN_IF_FALSE(allocations.InitGBufferAllocation(GetID(), m_root_signature_helper, true))\r\n    RETURN_IF_FALSE(m_root_signature_helper.AddTableRootParameter(\"LightingSamples\", RHIRootParameterDescriptorRangeType::SRV, 1, false, m_lighting_samples_allocation))\r\n    RETURN_IF_FALSE(m_root_signature_helper.AddTableRootParameter(\"ScreenUVOffset\", RHIRootParameterDescriptorRangeType::SRV, 1, false, m_screen_uv_offset_allocation))\r\n    RETURN_IF_FALSE(m_root_signature_helper.AddTableRootParameter(\"Output\", RHIRootParameterDescriptorRangeType::UAV, 1, true, m_output_allocation))\r\n    RETURN_IF_FALSE(m_aggregate_samples_output.RegisterSignature(m_root_signature_helper))\r\n    return true;\r\n}\r\n\r\nbool glTFComputePassReSTIRDirectLighting::SetupPipelineStateObject(glTFRenderResourceManager& resource_manager)\r\n{\r\n    RETURN_IF_FALSE(glTFComputePassBase::SetupPipelineStateObject(resource_manager))\r\n\r\n    m_dispatch_count = {resource_manager.GetSwapchain().GetWidth() / 8, resource_manager.GetSwapchain().GetHeight() / 8, 1};\r\n\r\n    RETURN_IF_FALSE(m_main_descriptor_heap->CreateUnOrderAccessViewInDescriptorHeap(resource_manager.GetDevice(), m_main_descriptor_heap->GetUsedDescriptorCount(),\r\n                *m_output, {m_output->GetRenderTargetFormat(), RHIResourceDimension::TEXTURE2D}, m_output_handle))\r\n\r\n    RETURN_IF_FALSE(m_main_descriptor_heap->CreateShaderResourceViewInDescriptorHeap(resource_manager.GetDevice(), m_main_descriptor_heap->GetUsedDescriptorCount(),\r\n                    *m_lighting_samples, {m_lighting_samples->GetRenderTargetFormat(), RHIResourceDimension::TEXTURE2D}, m_lighting_samples_handle))\r\n\r\n    RETURN_IF_FALSE(m_main_descriptor_heap->CreateShaderResourceViewInDescriptorHeap(resource_manager.GetDevice(), m_main_descriptor_heap->GetUsedDescriptorCount(),\r\n                *m_screen_uv_offset, {m_screen_uv_offset->GetRenderTargetFormat(), RHIResourceDimension::TEXTURE2D}, m_screen_uv_offset_handle))\r\n    \r\n    RETURN_IF_FALSE(m_aggregate_samples_output.CreateDescriptors(resource_manager, *m_main_descriptor_heap))\r\n    \r\n    for (unsigned i = 0; i < resource_manager.GetBackBufferCount(); ++i)\r\n    {\r\n        auto& GBuffer_output = resource_manager.GetFrameResourceManagerByIndex(i).GetGBufferForInit();\r\n        RETURN_IF_FALSE(GBuffer_output.InitGBufferSRVs(GetID(), *m_main_descriptor_heap, resource_manager))    \r\n    }\r\n    \r\n    GetComputePipelineStateObject().BindShaderCode(\r\n        R\"(glTFResources\\ShaderSource\\ComputeShader\\ReSTIRDirectLightingCS.hlsl)\", RHIShaderType::Compute, \"main\");\r\n    \r\n    auto& shader_macros = GetComputePipelineStateObject().GetShaderMacros();\r\n\r\n    // Add albedo, normal, depth register define\r\n    const auto& allocations = resource_manager.GetGBufferAllocations();\r\n    RETURN_IF_FALSE(allocations.UpdateShaderMacros(GetID(), shader_macros, true))\r\n\r\n    shader_macros.AddSRVRegisterDefine(\"LIGHTING_SAMPLES_REGISTER_INDEX\", m_lighting_samples_allocation.register_index, m_lighting_samples_allocation.space);\r\n    shader_macros.AddSRVRegisterDefine(\"SCREEN_UV_OFFSET_REGISTER_INDEX\", m_screen_uv_offset_allocation.register_index, m_screen_uv_offset_allocation.space);\r\n    shader_macros.AddUAVRegisterDefine(\"OUTPUT_TEX_REGISTER_INDEX\", m_output_allocation.register_index, m_output_allocation.space);\r\n    RETURN_IF_FALSE(m_aggregate_samples_output.AddShaderMacros(shader_macros))\r\n    \r\n    return true;\r\n}\r\n
===================================================================
diff --git a/glTFRenderer/glTFRenderPass/glTFComputePass/glTFComputePassReSTIRDirectLighting.cpp b/glTFRenderer/glTFRenderPass/glTFComputePass/glTFComputePassReSTIRDirectLighting.cpp
--- a/glTFRenderer/glTFRenderPass/glTFComputePass/glTFComputePassReSTIRDirectLighting.cpp	
+++ b/glTFRenderer/glTFRenderPass/glTFComputePass/glTFComputePassReSTIRDirectLighting.cpp	
@@ -128,6 +128,7 @@
 
     ImGui::Checkbox("EnableSpatialReuse", &m_pass_options.enable_spatial_reuse);
     ImGui::Checkbox("EnableTemporalReuse", &m_pass_options.enable_temporal_reuse);
+    ImGui::SliderInt("SpatialReusePixelRange", &m_pass_options.spatial_reuse_pixel_range, 0, 10);
 
     return true;
 }
Index: glTFRenderer/glTFResources/ShaderSource/ComputeShader/ReSTIRDirectLightingCS.hlsl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#ifndef RESTIR_DIRECT_LIGHTING_CS\r\n#define RESTIR_DIRECT_LIGHTING_CS\r\n\r\n#include \"glTFResources/ShaderSource/Lighting/LightingCommon.hlsl\"\r\n#include \"glTFResources/ShaderSource/LightPassCommon.hlsl\"\r\n#include \"glTFResources/ShaderSource/Math/MathCommon.hlsl\"\r\n#include \"glTFResources/ShaderSource/FrameStat.hlsl\"\r\n\r\nTexture2D albedoTex: ALBEDO_REGISTER_INDEX;\r\nTexture2D normalTex: NORMAL_REGISTER_INDEX;\r\nTexture2D depthTex: DEPTH_REGISTER_INDEX;\r\n\r\nTexture2D LightingSamples : LIGHTING_SAMPLES_REGISTER_INDEX;\r\nTexture2D ScreenUVOffset : SCREEN_UV_OFFSET_REGISTER_INDEX;\r\n\r\nRWTexture2D<float4> Output: OUTPUT_TEX_REGISTER_INDEX;\r\n\r\nRWTexture2D<float4> aggregate_samples_output : AGGREGATE_OUTPUT_REGISTER_INDEX;\r\nTexture2D<float4> aggregate_samples_back_buffer : AGGREGATE_BACKBUFFER_REGISTER_INDEX;\r\n\r\nSamplerState defaultSampler : DEFAULT_SAMPLER_REGISTER_INDEX;\r\n\r\ncbuffer RayTracingDIPassOptions: RAY_TRACING_DI_POSTPROCESS_OPTION_CBV_INDEX\r\n{\r\n    bool enable_spatial_reuse;\r\n    bool enable_temporal_reuse;\r\n};\r\n\r\nstatic int spatial_reuse_range = 0;\r\n\r\nfloat3 GetWorldPosition(int2 texCoord)\r\n{\r\n    float depth = depthTex.Load(int3(texCoord, 0)).r;\r\n\r\n    float2 uv = texCoord / float2(viewport_width - 1, viewport_height - 1);\r\n    \r\n    // Flip uv.y is important\r\n    float4 clipSpaceCoord = float4(2 * uv.x - 1.0, 1 - 2 * uv.y, depth, 1.0);\r\n    float4 viewSpaceCoord = mul(inverseProjectionMatrix, clipSpaceCoord);\r\n    viewSpaceCoord /= viewSpaceCoord.w;\r\n\r\n    float4 worldSpaceCoord = mul(inverseViewMatrix, viewSpaceCoord);\r\n    return worldSpaceCoord.xyz;\r\n}\r\n\r\nvoid ReservoirTemporalReuse(inout RngStateType rng_state, uint2 coord, PointLightShadingInfo shading_info, float3 view, out float4 out_sample)\r\n{\r\n    out_sample = 0.0;\r\n    \r\n    float4 lighting_sample = LightingSamples.Load(int3(coord, 0));\r\n    int light_index = round(lighting_sample.x);\r\n    float light_weight = lighting_sample.y;\r\n    \r\n    float2 prev_uv = ScreenUVOffset.Load(int3(coord, 0)).xy;\r\n    uint2 prev_frame_coord = uint2(round(prev_uv.x * viewport_width), round(prev_uv.y * viewport_height));\r\n    float4 old_lighting_sample = aggregate_samples_back_buffer.Load(int3(prev_frame_coord, 0));\r\n    int old_light_index = round(old_lighting_sample.x);\r\n    // temporal ratio to reduce old weight ()\r\n    float old_light_weight = old_lighting_sample.y;\r\n\r\n    if (light_index < 0 || old_light_index < 0)\r\n    {\r\n        out_sample.xy = old_light_weight < light_weight ? float2(light_index, light_weight): float2(old_light_index, old_light_weight);\r\n        return;\r\n    }\r\n\r\n    if (light_index == old_light_index)\r\n    {\r\n        out_sample.xy = lighting_sample.xy;\r\n        return;\r\n    }\r\n    \r\n    Reservoir reservoir; InitReservoir(reservoir);\r\n    AddReservoirSample(rng_state, reservoir, light_index, 0.5, luminance(GetLightingByIndex(light_index, shading_info, view)), light_weight);\r\n    AddReservoirSample(rng_state, reservoir, old_light_index, 0.5, luminance(GetLightingByIndex(old_light_index, shading_info, view)), old_light_weight);\r\n    GetReservoirSelectSample(reservoir, out_sample.x, out_sample.y);\r\n}\r\n\r\nvoid ReservoirSpatialReuse(inout RngStateType rng_state, uint2 coord, PointLightShadingInfo shading_info, float3 view, inout float4 out_sample)\r\n{\r\n    Reservoir reservoir;\r\n    InitReservoir(reservoir);\r\n\r\n    float mis_weight = 1.0 / (2 * spatial_reuse_range + 1) * (2 * spatial_reuse_range + 1);\r\n    for (int x = -spatial_reuse_range; x <= spatial_reuse_range; ++x)\r\n    {\r\n        for (int y = -spatial_reuse_range; y <= spatial_reuse_range; ++y)\r\n        {\r\n            if (x == 0 && y == 0)\r\n            {\r\n                AddReservoirSample(rng_state, reservoir, out_sample.x, mis_weight, luminance(GetLightingByIndex(out_sample.x, shading_info, view)), out_sample.y);\r\n                continue;\r\n            }\r\n            \r\n            int2 spatial_reuse_coord = (int2)coord + int2(x, y);\r\n            if (spatial_reuse_coord.x < 0 || spatial_reuse_coord.y < 0 || spatial_reuse_coord.x >= viewport_width || spatial_reuse_coord.y >= viewport_height)\r\n            {\r\n                continue;\r\n            }\r\n            \r\n            float4 lighting_sample = LightingSamples.Load(int3(spatial_reuse_coord, 0));\r\n            int light_index = round(lighting_sample.x);\r\n            float light_weight = lighting_sample.y;\r\n            if (light_index >= 0 && light_weight > 0.0)\r\n            {\r\n                AddReservoirSample(rng_state, reservoir, light_index, mis_weight, luminance(GetLightingByIndex(light_index, shading_info, view)), light_weight);\r\n            }\r\n        }\r\n    }\r\n    \r\n    GetReservoirSelectSample(reservoir, out_sample.x, out_sample.y);\r\n}\r\n\r\n[numthreads(8, 8, 1)]\r\nvoid main(int3 dispatchThreadID : SV_DispatchThreadID)\r\n{\r\n    Output[dispatchThreadID.xy] = 0.0;\r\n    \r\n    uint4 rng = initRNG(dispatchThreadID.xy, uint2(viewport_width, viewport_height), frame_index);\r\n    \r\n    float3 world_position = GetWorldPosition(dispatchThreadID.xy);\r\n\r\n    float4 albedo_buffer_data = albedoTex.Load(int3(dispatchThreadID.xy, 0));\r\n    float4 normal_buffer_data = normalTex.Load(int3(dispatchThreadID.xy, 0));\r\n\r\n    float3 albedo = albedo_buffer_data.xyz;\r\n    float metallic = albedo_buffer_data.w;\r\n    \r\n    float3 normal = normalize(2 * normal_buffer_data.xyz - 1);\r\n    float roughness = normal_buffer_data.w;\r\n\r\n    PointLightShadingInfo shading_info;\r\n    shading_info.albedo = albedo;\r\n    shading_info.position = world_position;\r\n    shading_info.normal = normal;\r\n    shading_info.metallic = metallic;\r\n    shading_info.roughness = roughness;\r\n    \r\n    float3 view = normalize(view_position.xyz - world_position);\r\n\r\n    float4 final_samples = LightingSamples.Load(int3(dispatchThreadID.xy, 0));\r\n    \r\n    if (enable_temporal_reuse)\r\n    {\r\n        ReservoirTemporalReuse(rng, dispatchThreadID.xy, shading_info, view, final_samples);    \r\n    }\r\n    \r\n    if (enable_spatial_reuse)\r\n    {\r\n        ReservoirSpatialReuse(rng, dispatchThreadID.xy, shading_info, view, final_samples);    \r\n    }\r\n    \r\n    int light_index = final_samples.x;\r\n    float lighting_weight = final_samples.y;\r\n    if (lighting_weight > 0.0 && light_index >= 0)\r\n    {\r\n        float3 final_lighting = lighting_weight * GetLightingByIndex(light_index, shading_info, view);\r\n        Output[dispatchThreadID.xy] = float4(LinearToSrgb(final_lighting), 1.0);\r\n    }\r\n    aggregate_samples_output[dispatchThreadID.xy] = final_samples;\r\n}\r\n\r\n\r\n#endif
===================================================================
diff --git a/glTFRenderer/glTFResources/ShaderSource/ComputeShader/ReSTIRDirectLightingCS.hlsl b/glTFRenderer/glTFResources/ShaderSource/ComputeShader/ReSTIRDirectLightingCS.hlsl
--- a/glTFRenderer/glTFResources/ShaderSource/ComputeShader/ReSTIRDirectLightingCS.hlsl	
+++ b/glTFRenderer/glTFResources/ShaderSource/ComputeShader/ReSTIRDirectLightingCS.hlsl	
@@ -20,13 +20,12 @@
 
 SamplerState defaultSampler : DEFAULT_SAMPLER_REGISTER_INDEX;
 
-cbuffer RayTracingDIPassOptions: RAY_TRACING_DI_POSTPROCESS_OPTION_CBV_INDEX
+cbuffer RayTracingDIPostProcessPassOptions: RAY_TRACING_DI_POSTPROCESS_OPTION_CBV_INDEX
 {
     bool enable_spatial_reuse;
     bool enable_temporal_reuse;
+    int spatial_reuse_pixel_range;
 };
-
-static int spatial_reuse_range = 0;
 
 float3 GetWorldPosition(int2 texCoord)
 {
@@ -81,14 +80,16 @@
     Reservoir reservoir;
     InitReservoir(reservoir);
 
-    float mis_weight = 1.0 / (2 * spatial_reuse_range + 1) * (2 * spatial_reuse_range + 1);
-    for (int x = -spatial_reuse_range; x <= spatial_reuse_range; ++x)
+    float mis_weight = 1.0 / (2 * spatial_reuse_pixel_range + 1) * (2 * spatial_reuse_pixel_range + 1);
+    for (int x = -spatial_reuse_pixel_range; x <= spatial_reuse_pixel_range; ++x)
     {
-        for (int y = -spatial_reuse_range; y <= spatial_reuse_range; ++y)
+        for (int y = -spatial_reuse_pixel_range; y <= spatial_reuse_pixel_range; ++y)
         {
             if (x == 0 && y == 0)
             {
-                AddReservoirSample(rng_state, reservoir, out_sample.x, mis_weight, luminance(GetLightingByIndex(out_sample.x, shading_info, view)), out_sample.y);
+                AddReservoirSample(rng_state, reservoir, out_sample.x, mis_weight,
+                    luminance(GetLightingByIndex(out_sample.x, shading_info, view)),
+                    out_sample.y);
                 continue;
             }
             
