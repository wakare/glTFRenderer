#include "DX12Shader.h"

#include <d3dcompiler.h>
#include <dxcapi.h>
#include <atlbase.h>

#include "glTFUtils/glTFUtils.h"

DX12Shader::DX12Shader()
= default;

DX12Shader::~DX12Shader()
= default;

bool DX12Shader::CompileShaderWithFXC()
{
    if (m_shader_file_path.empty() || !LoadShader(m_shader_file_path))
    {
        return false;
    }
    
    if (m_shader_content.empty() || m_shader_entry_function_name.empty())
    {
        // Not init shader content!
        assert(false);
        return false;
    }
    
    assert(m_macros.macroKey.size() == m_macros.macroValue.size());
    std::vector<D3D_SHADER_MACRO> dxShaderMacros;
    if (!m_macros.macroKey.empty())
    {
        for (size_t i = 0; i < m_macros.macroKey.size(); i++)
        {
            const std::string& key = m_macros.macroKey[i];
            const std::string& value = m_macros.macroValue[i];
            
            dxShaderMacros.push_back({key.c_str(), value.c_str()});
            LOG_FORMAT_FLUSH("[DEBUG] Compile shader:%s with macro %s = %s\n", m_shader_file_path.c_str(), key.c_str(), value.c_str())
        }
        dxShaderMacros.push_back({nullptr, nullptr});
    }
    
    ID3DBlob* shaderCompileResult = nullptr; // d3d blob for holding vertex shader bytecode
    ID3DBlob* errorBuff = nullptr; // a buffer holding the error data if any
    
    D3DCompile(m_shader_content.data(),
            m_shader_content.length(),
            nullptr,
            dxShaderMacros.data(),
            D3D_COMPILE_STANDARD_FILE_INCLUDE,
            m_shader_entry_function_name.c_str(),
            GetShaderCompilerTarget(), 
            D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION,
            0,
            &shaderCompileResult,
            &errorBuff);

    if (errorBuff)
    {
        LOG_FORMAT_FLUSH("[FATAL] Compile shader file %s failed\nresult: %s\n", m_shaderFilePath.c_str(), static_cast<const char*>(errorBuff->GetBufferPointer()));
        return false;
    }
    
    // store shader bytecode
    m_shader_byte_code.resize(shaderCompileResult->GetBufferSize());
    memcpy(m_shader_byte_code.data(), shaderCompileResult->GetBufferPointer(), shaderCompileResult->GetBufferSize());
    
    return true;
}

bool DX12Shader::CompileShaderWithDXC()
{
    if (m_shader_file_path.empty())
    {
        GLTF_CHECK(false);
        return false;
    }
    
    CComPtr<IDxcUtils> pUtils;
    CComPtr<IDxcCompiler3> pCompiler;
    DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&pUtils));
    DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&pCompiler));

    //
    // Create default include handler. (You can create your own...)
    //
    CComPtr<IDxcIncludeHandler> pIncludeHandler;
    pUtils->CreateDefaultIncludeHandler(&pIncludeHandler);

    const auto file_path = to_wide_string(m_shader_file_path);
    const auto target = to_wide_string(GetShaderCompilerTarget());

    TCHAR working_directory[MAX_PATH] = {0};
    GetCurrentDirectory(MAX_PATH, working_directory);
    
    std::vector<std::wstring> compile_argument_strings;
    compile_argument_strings.emplace_back(file_path.c_str());   // Optional shader source file name for error reporting and for PIX shader source view.
    compile_argument_strings.emplace_back(L"-T");
    compile_argument_strings.emplace_back(target.c_str());      // Target.
    compile_argument_strings.emplace_back(L"-Zi");              // Enable debug information.
    //compile_argument_strings.emplace_back(L"-Fo");
    //compile_argument_strings.emplace_back(L"myshader.bin");     // Optional. Stored in the pdb.
    compile_argument_strings.emplace_back(L"-Fd");
    compile_argument_strings.emplace_back(working_directory);     // The file name of the pdb. This must either be supplied or the autogenerated file name must be used.
    //compile_argument_strings.emplace_back(L"-Qstrip_reflect");  // Strip reflection into a separate blob.

    compile_argument_strings.emplace_back(L"-I");
    compile_argument_strings.emplace_back(working_directory);

#ifdef DEBUG
    compile_argument_strings.emplace_back(L"-Od");
#endif
    
    if (!m_shader_entry_function_name.empty())
    {
        compile_argument_strings.emplace_back(L"-E");
        compile_argument_strings.emplace_back(to_wide_string(m_shader_entry_function_name));
    }
    
    if (!m_macros.macroKey.empty())
    {
        for (size_t i = 0; i < m_macros.macroKey.size(); i++)
        {
            char define_string[256] = {'\0'};
            (void)snprintf(define_string, sizeof(define_string), "%s=%s", m_macros.macroKey[i].c_str(), m_macros.macroValue[i].c_str());
            LOG_FORMAT_FLUSH("[DEBUG] Compile shader file %s with macro %s\n", m_shader_file_path.c_str(), define_string)
            
            compile_argument_strings.emplace_back(L"-D"); 
            compile_argument_strings.emplace_back(to_wide_string(std::string(define_string)));
        }
    }

    std::vector<LPCWSTR> compile_argument_raws;
    compile_argument_raws.reserve(compile_argument_strings.size());
    for (const auto& argument : compile_argument_strings )
    {
        compile_argument_raws.push_back(argument.c_str());
    }
    
    // Open source file.  
    CComPtr<IDxcBlobEncoding> pSource = nullptr;
    pUtils->LoadFile(file_path.c_str(), nullptr, &pSource);
    DxcBuffer Source;
    Source.Ptr = pSource->GetBufferPointer();
    Source.Size = pSource->GetBufferSize();
    Source.Encoding = DXC_CP_ACP; // Assume BOM says UTF8 or UTF16 or this is ANSI text.

    // Compile it with specified arguments.
    CComPtr<IDxcResult> pResults;
    THROW_IF_FAILED(pCompiler->Compile(
        &Source,                // Source buffer.
        compile_argument_raws.data(),                // Array of pointers to arguments.
        compile_argument_raws.size(),      // Number of arguments.
        pIncludeHandler,        // User-provided interface to handle #include directives (optional).
        IID_PPV_ARGS(&pResults) // Compiler output status, buffer, and errors.) 
    ))

    // Print errors if present.
    CComPtr<IDxcBlobUtf8> pErrors = nullptr;
    pResults->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&pErrors), nullptr);
    // Note that d3dcompiler would return null if no errors or warnings are present.  
    // IDxcCompiler3::Compile will always return an error buffer, but its length will be zero if there are no warnings or errors.
    if (pErrors != nullptr && pErrors->GetStringLength() != 0)
    {
        wprintf(L"Warnings and Errors:\n%S\n", pErrors->GetStringPointer());
        LOG_FLUSH()
    }

    // Quit if the compilation failed.
    HRESULT hrStatus;
    pResults->GetStatus(&hrStatus);
    if (FAILED(hrStatus))
    {
        wprintf(L"Compilation Failed\n");
        return false;
    }

    static auto save_dxc_compile_output_to_disk = []( IDxcBlob* dxc_data, const std::string& output_file_path)
    {
        auto* data = dxc_data->GetBufferPointer();
        const auto data_size = dxc_data->GetBufferSize();

        std::ofstream output_file_stream(output_file_path, std::ios::out | std::ios::binary);
        GLTF_CHECK (output_file_stream.is_open());

        output_file_stream.write(static_cast<const char*>(data), data_size);
        output_file_stream.close();

        LOG_FORMAT("[DEBUG] Output shader compile output to file: %s\n", output_file_path.c_str());
    };
    
    // Save shader binary.
    CComPtr<IDxcBlob> pShader = nullptr;
    CComPtr<IDxcBlobUtf16> pShaderName = nullptr;
    THROW_IF_FAILED(pResults->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&pShader), &pShaderName))
    
    m_shader_byte_code.resize(pShader->GetBufferSize());
    memcpy(m_shader_byte_code.data(), pShader->GetBufferPointer(), pShader->GetBufferSize());

    std::string output_shader_hash = m_shader_file_path;
    
    if (pResults->HasOutput(DXC_OUT_SHADER_HASH))
    {
        CComPtr<IDxcBlob> shader_hash = nullptr;
        THROW_IF_FAILED(pResults->GetOutput(DXC_OUT_SHADER_HASH, IID_PPV_ARGS(&shader_hash), nullptr))
        if (shader_hash && shader_hash->GetBufferSize())
        {
            auto* pHashBuf = static_cast<DxcShaderHash*>(shader_hash->GetBufferPointer());
            char hash_string[32] = {'\0'};
            for(size_t i = 0; i < _countof(pHashBuf->HashDigest); ++i) {
                (void)snprintf(hash_string + i, 16, "%X", pHashBuf->HashDigest[i]);
            }

            const auto last_slash = min(m_shader_file_path.find_last_of('\\'), m_shader_file_path.find_last_of('/'));
            output_shader_hash = std::string(m_shader_file_path.c_str(), last_slash + 1) + std::string(hash_string);
        }
    }
    
    
    save_dxc_compile_output_to_disk( pShader, output_shader_hash + ".bin");
    if (pResults->HasOutput(DXC_OUT_PDB))
    {
        // Save shader pdb file.
        CComPtr<IDxcBlob> pShaderPDB = nullptr;
        CComPtr<IDxcBlobUtf16> pShaderPDBName = nullptr;
        if (SUCCEEDED(pResults->GetOutput(DXC_OUT_PDB, IID_PPV_ARGS(&pShaderPDB), &pShaderPDBName)))
        {
            save_dxc_compile_output_to_disk(pShaderPDB, output_shader_hash + ".pdb");
        }    
    }
    
    return true;
}

const std::vector<unsigned char>& DX12Shader::GetShaderByteCode() const
{
    return m_shader_byte_code;
}

bool DX12Shader::InitShader(const std::string& shader_file_path, RHIShaderType type, const std::string& entry_function_name,
                            const RayTracingShaderEntryFunctionNames& raytracing_entry_names)
{
    assert(m_type == RHIShaderType::Unknown);
    m_type = type;
    m_shader_file_path = shader_file_path;
    
    m_shader_entry_function_name = entry_function_name;
    m_raytracing_entry_names = raytracing_entry_names;
    
    return true;
}

bool DX12Shader::CompileShader()
{
    bool success = false;
    /*
    if (GetType() == RHIShaderType::RayTracing)
    {
        success = CompileShaderWithDXC();
    }
    else
    {
        success = CompileShaderWithFXC();
    }
    */
    success = CompileShaderWithDXC();
    return success;
}

const char* DX12Shader::GetShaderCompilerTarget() const
{
    // 5.0 is latest target for dx11 version
    switch (m_type) {
        /*
        case RHIShaderType::Vertex: return "vs_5_0";
        case RHIShaderType::Pixel: return "ps_5_0";
        case RHIShaderType::Compute: return "cs_5_0";
        */
        case RHIShaderType::Vertex: return "vs_6_3";
        case RHIShaderType::Pixel: return "ps_6_3";
        case RHIShaderType::Compute: return "cs_6_3";
        // raytracing shader will be compile into lib
        case RHIShaderType::RayTracing: return "lib_6_3";
    }

    assert(false);
    return "UnknownTarget";
}
