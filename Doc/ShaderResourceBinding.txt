 Shaderèµ„æºç»‘å®šå®Œæ•´æµç¨‹

  ğŸ“‹ ç›®å½•

  1. #æ•´ä½“æ¶æ„
  2. #shaderå£°æ˜èµ„æº
  3. #shaderç¼–è¯‘ä¸åå°„
  4. #æ ¹ç­¾ååˆ›å»º
  5. #æè¿°ç¬¦åˆ›å»ºä¸ç¼“å­˜
  6. #èµ„æºç»‘å®šæµç¨‹
  7. #å®Œæ•´ç¤ºä¾‹

  ---
  ğŸ—ï¸ æ•´ä½“æ¶æ„

  èµ„æºç»‘å®šç³»ç»Ÿé‡‡ç”¨å¤šé˜¶æ®µæµæ°´çº¿è®¾è®¡ï¼š

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Shaderæºç    â”‚ â†’ â”‚ Shaderç¼–è¯‘   â”‚ â†’ â”‚ Shaderåå°„   â”‚ â†’ â”‚ æ ¹ç­¾ååˆ›å»º   â”‚ â†’ â”‚ èµ„æºç»‘å®š     â”‚
  â”‚ (HLSL/GLSL) â”‚   â”‚  (DXIL/SPIRV)â”‚   â”‚ (å‚æ•°æå–)   â”‚   â”‚ (Layoutæ„å»º)â”‚   â”‚ (Descriptor) â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  æ ¸å¿ƒç»„ä»¶å…³ç³»

  RenderPass
    â””â”€ IRHIRootSignatureHelper
        â”œâ”€ RootSignatureLayout              // æ ¹ç­¾åå¸ƒå±€
        â”‚   â”œâ”€ RootSignatureParameterElement[]
        â”‚   â””â”€ RootSignatureStaticSamplerElement[]
        â”œâ”€ IRHIRootSignature                // å¹³å°ç›¸å…³æ ¹ç­¾å(DX12/Vulkan)
        â””â”€ std::map<name, RootSignatureAllocation>  // å‚æ•°åâ†’åˆ†é…ä¿¡æ¯æ˜ å°„

    â””â”€ IRHIDescriptorUpdater                // æè¿°ç¬¦æ›´æ–°å™¨
        â””â”€ ç»‘å®šæè¿°ç¬¦åˆ°æ ¹ç­¾åæ§½ä½

  ---
  ğŸ“ Shaderå£°æ˜èµ„æº

  1. Shaderå£°æ˜å® (ShaderDeclarationUtil.hlsl)

  ä¸ºäº†æ”¯æŒDX12å’ŒVulkanåŒåç«¯ï¼Œä½¿ç”¨è·¨å¹³å°å®ï¼š

  // DX12: ä½¿ç”¨è¯­ä¹‰(register)
  // Vulkan: ä½¿ç”¨layoutç»‘å®š
  #if DX_SHADER
      #define DECLARE_RESOURCE(x, IDENTITY) x : IDENTITY
  #else
      #define DECLARE_RESOURCE(x, IDENTITY) IDENTITY x
  #endif

  2. å®é™…Shaderä¸­çš„èµ„æºå£°æ˜

  SceneView.hlsl:6-29 - ç›¸æœºæ•°æ®ï¼ˆCBVï¼‰:
  DECLARE_RESOURCE(cbuffer SceneViewConstantBuffer, SCENE_VIEW_REGISTER_INDEX)
  {
      float4x4 viewMatrix;
      float4x4 projectionMatrix;
      float4x4 inverseViewMatrix;
      float4x4 inverseProjectionMatrix;

      float4x4 prev_view_matrix;
      float4x4 prev_projection_matrix;

      float4 view_position;
      uint viewport_width;
      uint viewport_height;

      float nearZ;
      float farZ;
  };

  å±•å¼€åï¼ˆDX12ï¼‰ï¼š
  cbuffer SceneViewConstantBuffer : register(b0, space0)
  {
      // ...
  };

  SceneMaterial.hlsl:27-29 - æè´¨æ•°æ®ï¼ˆSRV + Bindlessï¼‰:
  // æè´¨ä¿¡æ¯ç»“æ„åŒ–ç¼“å†²ï¼ˆSRVï¼‰
  DECLARE_RESOURCE(StructuredBuffer<MaterialShaderInfo> g_material_infos, SCENE_MATERIAL_INFO_REGISTER_INDEX);

  // Bindlessçº¹ç†æ•°ç»„ï¼ˆSRV Tableï¼‰
  DECLARE_RESOURCE(Texture2D<float4> bindless_material_textures[], SCENE_MATERIAL_TEXTURE_REGISTER_INDEX);

  // Sampler
  DECLARE_RESOURCE(SamplerState material_sampler, SCENE_MATERIAL_SAMPLER_REGISTER_INDEX);

  MeshPassCommon.hlsl:71 - ç½‘æ ¼å®ä¾‹æ•°æ®ï¼ˆSRVï¼‰:
  struct MeshInstanceInputData
  {
      float4x4 instance_transform;
      uint instance_material_id;
      uint normal_mapping;
      uint mesh_id;
      uint padding;
  };
  DECLARE_RESOURCE(StructuredBuffer<MeshInstanceInputData> g_mesh_instance_input_data, MESH_INSTANCE_INPUT_DATA_REGISTER_SRV_INDEX);

  3. å¯„å­˜å™¨ç´¢å¼•æ˜ å°„

  è™½ç„¶ä»£ç ä¸­æ²¡æœ‰æ‰¾åˆ°RegisterIndex.hï¼Œä½†ä»shaderåå°„æ—¥å¿—å¯ä»¥çœ‹åˆ°ç»‘å®šä¿¡æ¯ï¼š
  - SCENE_VIEW_REGISTER_INDEX â†’ register(b0, space0)
  - SCENE_MATERIAL_INFO_REGISTER_INDEX â†’ register(t1, space0)
  - SCENE_MATERIAL_TEXTURE_REGISTER_INDEX â†’ register(t2, space0) (Bindless)
  - MESH_INSTANCE_INPUT_DATA_REGISTER_SRV_INDEX â†’ register(t0, space0)

  ---
  ğŸ” Shaderç¼–è¯‘ä¸åå°„

  1. Shaderç¼–è¯‘ (IRHIShader::CompileShader)

  // ResourceManager.cpp:222
  bool IRHIShader::CompileShader() {
      // 1. åŠ è½½shaderæ–‡ä»¶
      LoadShader(m_shader_file_path);

      // 2. ç¼–è¯‘shader
      //    HLSL â†’ DXIL (DX12) æˆ– GLSL â†’ SPIRV (Vulkan)
      glTFShaderUtils::CompileShader(compile_desc, m_shader_byte_code);

      return true;
  }

  2. Shaderåå°„ (DX12Utils::ProcessShaderMetaData)

  DX12Utils.cpp:756-835 - è¿™æ˜¯æ•´ä¸ªç»‘å®šç³»ç»Ÿçš„æ ¸å¿ƒï¼š

  bool DX12Utils::ProcessShaderMetaData(IRHIShader& shader)
  {
      // 1. åˆ›å»ºDXCåå°„å·¥å…·
      ComPtr<IDxcUtils> utils;
      DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&utils));
      ComPtr<ID3D12ShaderReflection> refl;

      // 2. ä»ç¼–è¯‘åçš„å­—èŠ‚ç åˆ›å»ºåå°„å¯¹è±¡
      const auto& shader_bytecode = shader.GetShaderByteCode();
      DxcBuffer shader_bytecode_buffer{};
      shader_bytecode_buffer.Ptr = shader_bytecode.data();
      shader_bytecode_buffer.Size = shader_bytecode.size();
      utils->CreateReflection(&shader_bytecode_buffer, IID_PPV_ARGS(&refl));

      // 3. è·å–shaderæè¿°
      D3D12_SHADER_DESC sd{};
      refl->GetDesc(&sd);

      auto& shader_meta_data = shader.GetMetaData();

      // 4. éå†æ‰€æœ‰ç»‘å®šçš„èµ„æº
      for (UINT i = 0; i < sd.BoundResources; ++i)
      {
          D3D12_SHADER_INPUT_BIND_DESC bd{};
          refl->GetResourceBindingDesc(i, &bd);

          LOG_FORMAT_FLUSH("[Reflect] Shader %s contains var name:%s\nbinding: %d\nset index:%d\n",
              shader.GetMainEntry().c_str(), bd.Name, bd.BindPoint, bd.Space);

          // 5. æ„å»ºå‚æ•°ä¿¡æ¯
          RootParameterInfo parameter_info{};
          parameter_info.parameter_name = bd.Name;
          parameter_info.register_count = bd.BindCount;

          switch (bd.Type) {
          case D3D_SIT_CBUFFER:  // Constant Buffer
              parameter_info.is_buffer = true;
              parameter_info.type = RHIRootParameterType::CBV;
              break;

          case D3D_SIT_TEXTURE:  // Texture (SRV)
              parameter_info.is_buffer = false;
              parameter_info.type = RHIRootParameterType::DescriptorTable;
              // Bindlessæ£€æµ‹ï¼šbd.BindCount == 0 è¡¨ç¤ºæ— ç•Œæ•°ç»„[]
              parameter_info.register_count = bd.BindCount == 0 ? UINT_MAX : bd.BindCount;
              parameter_info.table_parameter_info.table_type = RHIDescriptorRangeType::SRV;
              if (bd.BindCount == 0) {
                  parameter_info.table_parameter_info.is_bindless = true;
              }
              break;

          case D3D_SIT_SAMPLER:  // Sampler
              parameter_info.is_buffer = false;
              parameter_info.type = RHIRootParameterType::Sampler;
              break;

          case D3D_SIT_UAV_RWTYPED:  // Typed UAV Texture
              parameter_info.is_buffer = false;
              parameter_info.type = RHIRootParameterType::DescriptorTable;
              parameter_info.register_count = bd.BindCount == 0 ? UINT_MAX : bd.BindCount;
              parameter_info.table_parameter_info.table_type = RHIDescriptorRangeType::UAV;
              if (bd.BindCount == 0) {
                  parameter_info.table_parameter_info.is_bindless = true;
              }
              break;

          case D3D_SIT_STRUCTURED:  // StructuredBuffer<T>
              parameter_info.is_buffer = true;
              parameter_info.type = RHIRootParameterType::SRV;
              break;

          case D3D_SIT_UAV_RWSTRUCTURED:  // RWStructuredBuffer<T>
              parameter_info.is_buffer = true;
              parameter_info.type = RHIRootParameterType::UAV;
              break;

          case D3D_SIT_UAV_RWBYTEADDRESS:  // RWByteAddressBuffer
              parameter_info.is_buffer = true;
              parameter_info.type = RHIRootParameterType::UAV;
              break;
          }

          // 6. ä¿å­˜å…ƒæ•°æ®ï¼ˆåç§°ã€Spaceã€Register Indexï¼‰
          shader_meta_data.root_parameter_infos.push_back({
              parameter_info,
              bd.Space,          // Register Space
              bd.BindPoint       // Register Index
          });
      }

      return true;
  }

  åå°„è¾“å‡ºç¤ºä¾‹ï¼š
  [Reflect] Shader main contains var name:SceneViewConstantBuffer
  binding: 0
  set index:0

  [Reflect] Shader main contains var name:g_mesh_instance_input_data
  binding: 0
  set index:0

  [Reflect] Shader main contains var name:g_material_infos
  binding: 1
  set index:0

  [Reflect] Shader main contains var name:bindless_material_textures
  binding: 2
  set index:0

  ---
  ğŸ”¨ æ ¹ç­¾ååˆ›å»º

  1. RenderPassåˆå§‹åŒ– (RenderPass::InitRenderPass)

  RenderPass.cpp:29-47ï¼š

  bool RenderPass::InitRenderPass(ResourceManager& resource_manager)
  {
      // 1. ä»shaderåå°„å…ƒæ•°æ®æ„å»ºæ ¹ç­¾å
      std::map<RHIShaderType, std::shared_ptr<IRHIShader>> shaders;
      for (const auto& shader_pair : m_desc.shaders)
      {
          auto shader = InternalResourceHandleTable::Instance().GetShader(shader_pair.second);
          auto& shader_meta_data = shader->GetMetaData();

          // éå†shaderä¸­çš„æ‰€æœ‰å‚æ•°
          for (const auto& root_parameter_info : shader_meta_data.root_parameter_infos)
          {
              RootSignatureAllocation allocation;

              // æ·»åŠ åˆ°æ ¹ç­¾åHelperï¼ˆä½¿ç”¨Spaceå’ŒRegister Indexï¼‰
              m_root_signature_helper.AddRootParameterWithRegisterCount2(
                  root_parameter_info.parameter_info,   // å‚æ•°ç±»å‹ã€æ•°é‡ç­‰
                  root_parameter_info.space,            // Register Space
                  root_parameter_info.register_index,   // Register Index
                  allocation                            // è¾“å‡ºï¼šåˆ†é…ä¿¡æ¯
              );

              // ä¿å­˜å‚æ•°ååˆ°åˆ†é…ä¿¡æ¯çš„æ˜ å°„
              m_shader_parameter_mapping.insert({
                  root_parameter_info.parameter_info.parameter_name,  // å¦‚ "g_material_infos"
                  allocation                                          // æ§½ä½ä¿¡æ¯
              });
          }

          shaders[shader->GetType()] = shader;
      }

      // 2. æ„å»ºæ ¹ç­¾å
      m_root_signature_helper.BuildRootSignature(
          resource_manager.GetDevice(),
          resource_manager.GetMemoryManager().GetDescriptorManager()
      );

      auto* m_root_signature = &m_root_signature_helper.GetRootSignature();
      m_root_signature->InitRootSignature(device, descriptor_manager);

      // 3. åˆ›å»ºPSO
      // ... (ç»‘å®šRTæ ¼å¼ã€æ·±åº¦çŠ¶æ€ç­‰)
      m_pipeline_state_object->InitPipelineStateObject(device, *m_root_signature, swapchain, shaders);

      // 4. åˆ›å»ºæè¿°ç¬¦æ›´æ–°å™¨
      m_descriptor_updater = RHIResourceFactory::CreateRHIResource<IRHIDescriptorUpdater>();

      return true;
  }

  2. æ ¹ç­¾åå‚æ•°æ·»åŠ  (IRHIRootSignatureHelper::AddRootParameterWithRegisterCount2)

  IRHIRootSignatureHelper.cpp:149-217ï¼š

  bool IRHIRootSignatureHelper::AddRootParameterWithRegisterCount2(
      const RootParameterInfo& parameter_info,
      unsigned space,           // Shaderä¸­çš„Register Space
      unsigned register_index,  // Shaderä¸­çš„Register Index
      RootSignatureAllocation& out_allocation)
  {
      // 1. ç¡®å®šå¯„å­˜å™¨ç±»å‹ (b/t/u/s)
      auto register_type = ToShaderRegisterType(parameter_info.type, parameter_info.table_parameter_info.table_type);
      /*
          CBV          â†’ b (Constant Buffer View)
          SRV          â†’ t (Texture/Structured Buffer)
          UAV          â†’ u (Unordered Access View)
          Sampler      â†’ s (Sampler)
      */

      out_allocation.parameter_name = parameter_info.parameter_name;
      out_allocation.type = parameter_info.type;
      out_allocation.register_type = register_type;

      // 2. Samplerç‰¹æ®Šå¤„ç†ï¼ˆé™æ€é‡‡æ ·å™¨ï¼‰
      if (parameter_info.type == RHIRootParameterType::Sampler)
      {
          out_allocation.global_parameter_index = m_layout.sampler_elements.size();
          out_allocation.register_begin_index = m_layout.sampler_elements.size();
          out_allocation.space = space;
          out_allocation.local_space_parameter_index = register_index;

          RootSignatureStaticSamplerElement sampler_element{};
          sampler_element.sampler_name = parameter_info.parameter_name;
          sampler_element.register_space = space;
          sampler_element.local_space_parameter_index = register_index;
          sampler_element.sample_index = m_layout.sampler_elements.size();
          sampler_element.address_mode = parameter_info.sampler_parameter_info.address_mode;
          sampler_element.filter_mode = parameter_info.sampler_parameter_info.filter_mode;

          m_layout.sampler_elements.push_back(sampler_element);
      }
      // 3. æ™®é€šèµ„æºå‚æ•°
      else
      {
          RootSignatureParameterElement element{};
          element.name = parameter_info.parameter_name;
          element.global_parameter_index = m_layout.last_parameter_index++;  // å…¨å±€æ§½ä½ç´¢å¼•
          element.is_buffer = parameter_info.is_buffer;

          if (parameter_info.type == RHIRootParameterType::Constant)
          {
              element.constant_value_count = parameter_info.constant_parameter_info.constant_value;
          }
          else if (parameter_info.type == RHIRootParameterType::DescriptorTable)
          {
              element.table_type = parameter_info.table_parameter_info.table_type;
              element.is_bindless = parameter_info.table_parameter_info.is_bindless;
          }

          // 4. Bindlesså¤„ç†
          if (element.is_bindless)
          {
              unsigned register_start = 0;
              unsigned register_end = UINT_MAX;  // æ— ç•Œ
              element.register_range = {register_start, register_end};
              element.space = space;
          }
          else
          {
              unsigned register_start = register_index;
              unsigned register_end = register_start + parameter_info.register_count;
              element.register_range = {register_start, register_end};
              element.space = space;
          }

          // 5. å¡«å……è¾“å‡ºåˆ†é…ä¿¡æ¯
          out_allocation.register_begin_index = element.register_range.first;
          out_allocation.global_parameter_index = element.global_parameter_index;
          out_allocation.space = element.space;
          out_allocation.bindless_descriptor = element.is_bindless;
          out_allocation.local_space_parameter_index = register_index;

          element.local_space_parameter_index = register_index;

          // 6. æ·»åŠ åˆ°å¸ƒå±€
          m_layout.parameter_elements[parameter_info.type].push_back(element);
      }

      return true;
  }

  å…³é”®æ•°æ®ç»“æ„ï¼š

  // RootSignatureAllocation - å‚æ•°åˆ†é…ä¿¡æ¯
  struct RootSignatureAllocation
  {
      std::string parameter_name;           // "g_material_infos"
      unsigned global_parameter_index;      // å…¨å±€æ§½ä½ç´¢å¼•ï¼ˆç”¨äºç»‘å®šï¼‰
      unsigned local_space_parameter_index; // Spaceå†…çš„æœ¬åœ°ç´¢å¼•
      unsigned register_begin_index;        // å¯„å­˜å™¨èµ·å§‹ç´¢å¼•
      unsigned space;                       // Register Space
      bool bindless_descriptor;             // æ˜¯å¦ä¸ºBindless
      RHIRootParameterType type;            // CBV/SRV/UAV/Table/Sampler
      RHIShaderRegisterType register_type;  // b/t/u/s
  };

  // RootSignatureLayout - æ ¹ç­¾åå¸ƒå±€
  struct RootSignatureLayout
  {
      // æŒ‰ç±»å‹ç»„ç»‡çš„å‚æ•°åˆ—è¡¨
      std::map<RHIRootParameterType, std::vector<RootSignatureParameterElement>> parameter_elements;

      // é™æ€é‡‡æ ·å™¨åˆ—è¡¨
      std::vector<RootSignatureStaticSamplerElement> sampler_elements;

      // å¯„å­˜å™¨è®¡æ•°å™¨
      std::map<RHIShaderRegisterType, unsigned> last_register_index;
      unsigned last_parameter_index;  // å…¨å±€å‚æ•°ç´¢å¼•è®¡æ•°å™¨
  };

  ---
  ğŸ’¾ æè¿°ç¬¦åˆ›å»ºä¸ç¼“å­˜

  1. æè¿°ç¬¦åˆ›å»ºæ—¶æœº

  æè¿°ç¬¦åœ¨RenderGraphNodeé¦–æ¬¡æ‰§è¡Œæ—¶åˆ›å»ºï¼Œå¹¶æŒ‰èŠ‚ç‚¹ç¼“å­˜ã€‚

  RendererInterface.cpp:632-666 - Bufferæè¿°ç¬¦åˆ›å»ºï¼š

  // RenderGraph::ExecuteRenderGraphNode ä¸­
  auto& render_pass_descriptor_resource = m_render_pass_descriptor_resources[render_graph_node_handle];

  for (const auto& buffer : render_graph_node_desc.draw_info.buffer_resources)
  {
      auto& root_signature_allocation = render_pass->GetRootSignatureAllocation(buffer.first);
      auto buffer_handle = buffer.second.buffer_handle;
      auto buffer_allocation = InternalResourceHandleTable::Instance().GetBuffer(buffer_handle);
      auto buffer_size = buffer_allocation->m_buffer->GetBufferDesc().width;

      // æ£€æŸ¥ç¼“å­˜
      if (!render_pass_descriptor_resource.m_buffer_descriptors.contains(buffer.first))
      {
          // æ ¹æ®ç±»å‹åˆ›å»ºæè¿°ç¬¦
          switch (buffer.second.binding_type)
          {
          case BufferBindingDesc::CBV:
              {
                  RHIBufferDescriptorDesc buffer_descriptor_desc(
                      RHIDataFormat::UNKNOWN,   // CBVä¸éœ€è¦æ ¼å¼
                      RHIViewType::RVT_CBV,     // CBVç±»å‹
                      buffer_size,              // å¤§å°
                      0                         // åç§»
                  );
                  GetDescriptorManager().CreateDescriptor(
                      GetDevice(),
                      buffer_allocation->m_buffer,  // Bufferèµ„æº
                      buffer_descriptor_desc,       // æè¿°ç¬¦æè¿°
                      render_pass_descriptor_resource.m_buffer_descriptors[buffer.first]  // è¾“å‡º
                  );
              }
              break;

          case BufferBindingDesc::SRV:
              {
                  RHISRVStructuredBufferDesc srv_buffer_desc{
                      buffer.second.stride,            // ç»“æ„ä½“æ­¥é•¿
                      buffer.second.count,             // å…ƒç´ æ•°é‡
                      buffer.second.is_structured_buffer
                  };
                  RHIBufferDescriptorDesc buffer_descriptor_desc(
                      RHIDataFormat::UNKNOWN,
                      RHIViewType::RVT_SRV,
                      buffer_size,
                      0,
                      srv_buffer_desc
                  );
                  GetDescriptorManager().CreateDescriptor(...);
              }
              break;

          case BufferBindingDesc::UAV:
              {
                  RHIUAVStructuredBufferDesc uav_buffer_desc{
                      buffer.second.stride,
                      buffer.second.count,
                      buffer.second.is_structured_buffer,
                      buffer.second.use_count_buffer,
                      buffer.second.count_buffer_offset
                  };
                  RHIBufferDescriptorDesc buffer_descriptor_desc(...);
                  GetDescriptorManager().CreateDescriptor(...);
              }
              break;
          }

          // ç¼“å­˜æè¿°ç¬¦
          render_pass_descriptor_resource.m_buffer_descriptors[buffer.first] = descriptor;
      }

      // ... ç»§ç»­ç»‘å®šæµç¨‹
  }

  RendererInterface.cpp:683-728 - Textureæè¿°ç¬¦åˆ›å»ºï¼š

  for (const auto& texture : render_graph_node_desc.draw_info.texture_resources)
  {
      const bool is_texture_table = texture.second.textures.size() > 1;
      auto& root_signature_allocation = render_pass->GetRootSignatureAllocation(texture.first);

      // æ£€æŸ¥ç¼“å­˜
      if (!render_pass_descriptor_resource.m_texture_descriptors.contains(texture.first) &&
          !render_pass_descriptor_resource.m_texture_descriptor_tables.contains(texture.first))
      {
          auto texture_handles = texture.second.textures;
          std::vector<std::shared_ptr<IRHITextureDescriptorAllocation>> descriptor_allocations;

          // ä¸ºæ¯ä¸ªçº¹ç†åˆ›å»ºæè¿°ç¬¦
          for (const auto handle : texture_handles)
          {
              auto texture_allocation = InternalResourceHandleTable::Instance().GetTexture(handle);

              RHITextureDescriptorDesc texture_descriptor_desc{
                  texture_allocation->m_texture->GetTextureFormat(),
                  RHIResourceDimension::TEXTURE2D,
                  texture.second.type == TextureBindingDesc::SRV ? RHIViewType::RVT_SRV : RHIViewType::RVT_UAV
              };

              std::shared_ptr<IRHITextureDescriptorAllocation> texture_descriptor = nullptr;
              GetDescriptorManager().CreateDescriptor(
                  GetDevice(),
                  texture_allocation->m_texture,
                  texture_descriptor_desc,
                  texture_descriptor
              );

              descriptor_allocations.push_back(texture_descriptor);
          }

          // å•ä¸ªçº¹ç† vs çº¹ç†æ•°ç»„
          if (is_texture_table)
          {
              // åˆ›å»ºæè¿°ç¬¦è¡¨ï¼ˆBindless Arrayï¼‰
              RHIDescriptorTableDesc table_desc{};
              table_desc.table_type = texture.second.type == TextureBindingDesc::SRV ?
                  RHIDescriptorRangeType::SRV : RHIDescriptorRangeType::UAV;
              table_desc.num_descriptors = descriptor_allocations.size();

              std::shared_ptr<IRHIDescriptorTable> descriptor_table = nullptr;
              GetDescriptorManager().CreateDescriptorTable(
                  GetDevice(),
                  table_desc,
                  descriptor_allocations,
                  descriptor_table
              );

              render_pass_descriptor_resource.m_texture_descriptor_tables[texture.first] = descriptor_table;
              render_pass_descriptor_resource.m_texture_descriptor_table_source_data[texture.first] = descriptor_allocations;
          }
          else
          {
              render_pass_descriptor_resource.m_texture_descriptors[texture.first] = descriptor_allocations[0];
          }
      }

      // ... ç»§ç»­ç»‘å®šæµç¨‹
  }

  2. æè¿°ç¬¦ç¼“å­˜ç»“æ„

  // RenderGraph.h:157-163
  struct RenderPassDescriptorResource
  {
      std::map<std::string, std::shared_ptr<IRHIBufferDescriptorAllocation>> m_buffer_descriptors;
      std::map<std::string, std::shared_ptr<IRHITextureDescriptorAllocation>> m_texture_descriptors;
      std::map<std::string, std::shared_ptr<IRHIDescriptorTable>> m_texture_descriptor_tables;
      std::map<std::string, std::vector<std::shared_ptr<IRHITextureDescriptorAllocation>>> m_texture_descriptor_table_source_data;
  };

  // RenderGraphä¸­çš„ç¼“å­˜Mapï¼ˆæŒ‰RenderGraphNodeå¥æŸ„ç´¢å¼•ï¼‰
  std::map<RenderGraphNodeHandle, RenderPassDescriptorResource> m_render_pass_descriptor_resources;

  ---
  ğŸ”— èµ„æºç»‘å®šæµç¨‹

  1. ç»‘å®šé˜¶æ®µæ¦‚è§ˆ

  // RenderGraph::ExecuteRenderGraphNode æ‰§è¡Œæµç¨‹
  void ExecuteRenderGraphNode(IRHICommandList& cmd, RenderGraphNodeHandle node_handle, ...)
  {
      // 1. è®¾ç½®ç®¡çº¿çŠ¶æ€
      SetPipelineState(cmd, pso);
      SetRootSignature(cmd, root_signature, pipeline_type);

      // 2. ç»‘å®šæè¿°ç¬¦å †
      GetDescriptorManager().BindDescriptorContext(cmd);

      // 3. ç»‘å®šBufferèµ„æºï¼ˆCBV/SRV/UAVï¼‰
      for (auto& buffer : node_desc.draw_info.buffer_resources) {
          // 3.1 è·å–æ ¹ç­¾åæ§½ä½ä¿¡æ¯
          auto& root_allocation = render_pass->GetRootSignatureAllocation(buffer.first);

          // 3.2 è·å–æˆ–åˆ›å»ºæè¿°ç¬¦
          auto descriptor = GetOrCreateDescriptor(buffer);

          // 3.3 è½¬æ¢èµ„æºçŠ¶æ€
          buffer_allocation->m_buffer->Transition(cmd, target_state);

          // 3.4 ç»‘å®šæè¿°ç¬¦åˆ°æ§½ä½
          render_pass->GetDescriptorUpdater().BindDescriptor(
              cmd, pipeline_type, root_allocation, *descriptor
          );
      }

      // 4. ç»‘å®šTextureèµ„æºï¼ˆSRV/UAVï¼‰
      for (auto& texture : node_desc.draw_info.texture_resources) {
          // ç±»ä¼¼Bufferç»‘å®šæµç¨‹
      }

      // 5. ç»‘å®šRenderTargetä½œä¸ºTextureï¼ˆç”¨äºé‡‡æ ·ï¼‰
      for (auto& rt_texture : node_desc.draw_info.render_target_texture_resources) {
          // ç±»ä¼¼Textureç»‘å®šæµç¨‹
      }

      // 6. æœ€ç»ˆåŒ–æè¿°ç¬¦æ›´æ–°
      render_pass->GetDescriptorUpdater().FinalizeUpdateDescriptors(device, cmd, root_signature);

      // 7. å¼€å§‹æ¸²æŸ“å’Œæ‰§è¡Œç»˜åˆ¶å‘½ä»¤
      BeginRendering(cmd, rendering_info);
      ExecuteDrawCommands(cmd, execute_commands);
      EndRendering(cmd);
  }

  2. DX12æè¿°ç¬¦ç»‘å®š (DX12DescriptorUpdater::BindDescriptor)

  DX12DescriptorUpdater.cpp:7-51ï¼š

  bool DX12DescriptorUpdater::BindDescriptor(
      IRHICommandList& command_list,
      RHIPipelineType pipeline,
      const RootSignatureAllocation& root_signature_allocation,  // æ§½ä½ä¿¡æ¯
      const IRHIDescriptorAllocation& allocation)                // æè¿°ç¬¦
  {
      const auto& desc = allocation.GetDesc();

      switch (desc.m_dimension) {
      case RHIResourceDimension::BUFFER:
          {
              if (desc.m_view_type == RHIViewType::RVT_CBV)
              {
                  // ç»‘å®šCBVåˆ°æ ¹å‚æ•°æ§½ä½
                  DX12Utils::DX12Instance().SetCBVToRootParameterSlot(
                      command_list,
                      root_signature_allocation.global_parameter_index,  // æ§½ä½ç´¢å¼•
                      allocation,                                        // æè¿°ç¬¦
                      pipeline == RHIPipelineType::Graphics              // Graphics/Compute
                  );
              }
              else if (desc.m_view_type == RHIViewType::RVT_SRV)
              {
                  // ç»‘å®šSRVåˆ°æ ¹å‚æ•°æ§½ä½
                  DX12Utils::DX12Instance().SetSRVToRootParameterSlot(...);
              }
              else if (desc.m_view_type == RHIViewType::RVT_UAV)
              {
                  // ç»‘å®šUAVåˆ°æ ¹å‚æ•°æ§½ä½
                  DX12Utils::DX12Instance().SetUAVToRootParameterSlot(...);
              }
          }
          break;

      case RHIResourceDimension::TEXTURE2D:
      case RHIResourceDimension::TEXTURECUBE:
      // ... å…¶ä»–çº¹ç†ç±»å‹
          {
              // ç»‘å®šçº¹ç†æè¿°ç¬¦è¡¨åˆ°æ ¹å‚æ•°æ§½ä½
              DX12Utils::DX12Instance().SetDTToRootParameterSlot(
                  command_list,
                  root_signature_allocation.global_parameter_index,
                  allocation,
                  pipeline == RHIPipelineType::Graphics
              );
          }
          break;
      }

      return true;
  }

  3. DX12åº•å±‚ç»‘å®šå®ç° (DX12Utils)

  DX12Utils.cpp:367-400ï¼š

  // CBVç»‘å®š
  bool DX12Utils::SetCBVToRootParameterSlot(
      IRHICommandList& command_list,
      unsigned slot_index,
      const IRHIDescriptorAllocation& handle,
      bool isGraphicsPipeline)
  {
      auto* dxCommandList = dynamic_cast<DX12CommandList&>(command_list).GetCommandList();
      auto gpu_handle = dynamic_cast<const DX12BufferDescriptorAllocation&>(handle).m_gpu_handle;

      if (isGraphicsPipeline)
      {
          // Graphics Pipeline: SetGraphicsRootConstantBufferView
          dxCommandList->SetGraphicsRootConstantBufferView(slot_index, gpu_handle);
      }
      else
      {
          // Compute Pipeline: SetComputeRootConstantBufferView
          dxCommandList->SetComputeRootConstantBufferView(slot_index, gpu_handle);
      }

      return true;
  }

  // SRVç»‘å®š
  bool DX12Utils::SetSRVToRootParameterSlot(
      IRHICommandList& command_list,
      unsigned slot_index,
      const IRHIDescriptorAllocation& handle,
      bool isGraphicsPipeline)
  {
      auto* dxCommandList = dynamic_cast<DX12CommandList&>(command_list).GetCommandList();
      auto gpu_handle = dynamic_cast<const DX12BufferDescriptorAllocation&>(handle).m_gpu_handle;

      if (isGraphicsPipeline)
      {
          dxCommandList->SetGraphicsRootShaderResourceView(slot_index, gpu_handle);
      }
      else
      {
          dxCommandList->SetComputeRootShaderResourceView(slot_index, gpu_handle);
      }

      return true;
  }

  // Descriptor Tableç»‘å®š
  bool DX12Utils::SetDTToRootParameterSlot(
      IRHICommandList& command_list,
      unsigned slot_index,
      const IRHIDescriptorAllocation& handle,
      bool isGraphicsPipeline)
  {
      auto* dxCommandList = dynamic_cast<DX12CommandList&>(command_list).GetCommandList();
      auto gpu_handle = dynamic_cast<const DX12TextureDescriptorAllocation&>(handle).m_gpu_handle;

      if (isGraphicsPipeline)
      {
          dxCommandList->SetGraphicsRootDescriptorTable(slot_index, {gpu_handle});
      }
      else
      {
          dxCommandList->SetComputeRootDescriptorTable(slot_index, {gpu_handle});
      }

      return true;
  }

  ---
  ğŸ“š å®Œæ•´ç¤ºä¾‹

  ç¤ºä¾‹1ï¼šç›¸æœºBufferç»‘å®š

  Shaderä¸­å£°æ˜ (SceneView.hlsl):
  cbuffer SceneViewConstantBuffer : register(b0, space0)
  {
      float4x4 viewMatrix;
      float4x4 projectionMatrix;
      // ...
  };

  åº”ç”¨å±‚ç»‘å®š (RendererModuleCamera):
  // 1. åˆ›å»ºBuffer
  bool RendererModuleCamera::FinalizeModule(ResourceOperator& op)
  {
      BufferDesc camera_buffer_desc{};
      camera_buffer_desc.name = "CameraBuffer";
      camera_buffer_desc.usage = USAGE_CBV;
      camera_buffer_desc.type = UPLOAD;  // CPUå¯å†™
      camera_buffer_desc.size = sizeof(ViewBuffer);

      m_camera_buffer_handle = op.CreateBuffer(camera_buffer_desc);
      return true;
  }

  // 2. ç»‘å®šåˆ°DrawDesc
  bool RendererModuleCamera::BindDrawCommands(RenderPassDrawDesc& out_draw_desc)
  {
      BufferBindingDesc camera_binding{};
      camera_binding.buffer_handle = m_camera_buffer_handle;
      camera_binding.binding_type = BufferBindingDesc::CBV;

      // åç§°å¿…é¡»ä¸shaderä¸­çš„åç§°ä¸€è‡´
      out_draw_desc.buffer_resources["SceneViewConstantBuffer"] = camera_binding;
      return true;
  }

  // 3. æ¯å¸§æ›´æ–°
  bool RendererModuleCamera::Tick(ResourceOperator& op, unsigned long long interval)
  {
      ViewBuffer view_data{};
      view_data.viewMatrix = m_camera->GetViewMatrix();
      view_data.projectionMatrix = m_camera->GetProjectionMatrix();
      // ...

      BufferUploadDesc upload_desc{};
      upload_desc.data = &view_data;
      upload_desc.size = sizeof(view_data);

      op.UploadBufferData(m_camera_buffer_handle, upload_desc);
      return true;
  }

  ç»‘å®šæµç¨‹ï¼š
  1. Shaderç¼–è¯‘ â†’ åå°„æ£€æµ‹åˆ° "SceneViewConstantBuffer" (b0, space0)
  2. RenderPassåˆ›å»º â†’ æ·»åŠ åˆ°æ ¹ç­¾åï¼ˆæ§½ä½0ï¼ŒCBVç±»å‹ï¼‰
  3. é¦–æ¬¡ç»˜åˆ¶ â†’ åˆ›å»ºCBVæè¿°ç¬¦å¹¶ç¼“å­˜
  4. æ¯å¸§ç»˜åˆ¶ â†’
     - ä¸Šä¼ æ•°æ®åˆ°Buffer
     - ç»‘å®šæè¿°ç¬¦åˆ°æ§½ä½0
     - SetGraphicsRootConstantBufferView(0, gpu_virtual_address)
  5. Shaderè®¿é—® â†’ ç›´æ¥ä½¿ç”¨ viewMatrixã€projectionMatrix

  ç¤ºä¾‹2ï¼šBindlessæè´¨çº¹ç†

  Shaderä¸­å£°æ˜ (SceneMaterial.hlsl):
  // æè´¨ä¿¡æ¯
  StructuredBuffer<MaterialShaderInfo> g_material_infos : register(t1, space0);

  // Bindlessçº¹ç†æ•°ç»„
  Texture2D<float4> bindless_material_textures[] : register(t2, space0);

  // Sampler
  SamplerState material_sampler : register(s0, space0);

  // ä½¿ç”¨
  float4 SampleAlbedoTexture(uint material_id, float2 uv)
  {
      MaterialShaderInfo info = g_material_infos[material_id];

      if (info.albedo_tex_index != INVALID_INDEX)
      {
          // åŠ¨æ€ç´¢å¼•çº¹ç†æ•°ç»„
          return bindless_material_textures[info.albedo_tex_index].Sample(material_sampler, uv);
      }

      return info.albedo;  // ä½¿ç”¨é»˜è®¤é¢œè‰²
  }

  åº”ç”¨å±‚ç»‘å®š (RendererModuleMaterial):
  bool RendererModuleMaterial::BindDrawCommands(RenderPassDrawDesc& out_draw_desc)
  {
      // 1. ç»‘å®šæè´¨ä¿¡æ¯Bufferï¼ˆSRVï¼‰
      BufferBindingDesc material_info_binding{};
      material_info_binding.buffer_handle = m_material_info_buffer_handle;
      material_info_binding.binding_type = BufferBindingDesc::SRV;
      material_info_binding.stride = sizeof(MaterialShaderInfo);
      material_info_binding.count = m_material_count;
      material_info_binding.is_structured_buffer = true;

      out_draw_desc.buffer_resources["g_material_infos"] = material_info_binding;

      // 2. ç»‘å®šBindlessçº¹ç†æ•°ç»„ï¼ˆSRV Tableï¼‰
      TextureBindingDesc texture_array_binding{};
      texture_array_binding.textures = m_all_material_textures;  // std::vector<TextureHandle>
      texture_array_binding.type = TextureBindingDesc::SRV;

      out_draw_desc.texture_resources["bindless_material_textures"] = texture_array_binding;

      return true;
  }

  ç»‘å®šæµç¨‹ï¼š
  1. Shaderåå°„ â†’ æ£€æµ‹åˆ° bindless_material_textures[]ï¼ˆBindCount=0ï¼ŒBindlessï¼‰
  2. æ ¹ç­¾ååˆ›å»º â†’ æ·»åŠ SRV Descriptor Tableï¼ˆæ§½ä½2ï¼Œæ— ç•Œæ•°ç»„ï¼‰
  3. æè¿°ç¬¦åˆ›å»º â†’
     - ä¸ºæ¯ä¸ªçº¹ç†åˆ›å»ºSRVæè¿°ç¬¦
     - åˆ›å»ºDescriptor Tableï¼ŒåŒ…å«æ‰€æœ‰çº¹ç†æè¿°ç¬¦
  4. ç»‘å®š â†’ SetGraphicsRootDescriptorTable(2, descriptor_table_gpu_handle)
  5. Shaderè®¿é—® â†’ bindless_material_textures[dynamic_index]

  ---
  ğŸ“Š å…³é”®è®¾è®¡æ€»ç»“

  ä¼˜åŠ¿

  1. è‡ªåŠ¨åŒ–ï¼š
    - Shaderåå°„è‡ªåŠ¨æå–ç»‘å®šä¿¡æ¯
    - æ ¹ç­¾åè‡ªåŠ¨æ„å»º
    - æ— éœ€æ‰‹åŠ¨æŒ‡å®šæ§½ä½
  2. ç±»å‹å®‰å…¨ï¼š
    - å‚æ•°ååŒ¹é…ï¼ˆshaderåç§° â†” åº”ç”¨å±‚åç§°ï¼‰
    - ç¼–è¯‘æ—¶æ£€æŸ¥ç»‘å®šç±»å‹
  3. æ€§èƒ½ä¼˜åŒ–ï¼š
    - æè¿°ç¬¦æŒ‰Passç¼“å­˜ï¼ˆé¿å…é‡å¤åˆ›å»ºï¼‰
    - Bindlessçº¹ç†ï¼ˆå‡å°‘çŠ¶æ€åˆ‡æ¢ï¼‰
    - æ ¹ç­¾åå…±äº«ï¼ˆå¤šä¸ªPassä½¿ç”¨ç›¸åŒå¸ƒå±€ï¼‰
  4. åŒåç«¯é€æ˜ï¼š
    - DX12å’ŒVulkanä½¿ç”¨ç›¸åŒçš„é«˜å±‚API
    - åº•å±‚è‡ªåŠ¨è½¬æ¢ï¼ˆRootParameter â†” DescriptorSetï¼‰

  é™åˆ¶ä¸æ³¨æ„äº‹é¡¹

  1. å‘½åä¸€è‡´æ€§ï¼šåº”ç”¨å±‚èµ„æºåå¿…é¡»ä¸shaderä¸­å®Œå…¨åŒ¹é…
  2. Space/Registerç®¡ç†ï¼šéœ€è¦é¿å…å†²çª
  3. æè¿°ç¬¦å †å¤§å°ï¼šBindlesséœ€è¦è¶³å¤Ÿå¤§çš„å †
  4. ç¼“å­˜å¤±æ•ˆï¼šè¿è¡Œæ—¶æ›´æ¢èµ„æºéœ€è¦æ¸…é™¤æè¿°ç¬¦ç¼“å­˜
